## Run Instructions:
Below command can be used to run the server and clients has to be run separately ( telnet can be used)
Server is listening on localhost:9000

run go server.go

###Test Instruction:
Key-Value server can be tested by hitting below command assuming both the files server.go and server_test.go are in same directory

run test

To display which all tests are running, one can use below command

run test -v


## Work Completed:
1)Implemented basic operations set,get,getm,delete,cas
2)Handled concurrency using locks
3)Used priority queue(MIN-HEAP) for periodic cleanup of expired key-value pairs
4)Tested code on 
	i) Functioanlity for all the basic functions.
	ii) Expiry of key-value pair
	iii) Tested concurrent set operaton by multiple cients and at last validated result by comparing version number
	iv) Stress testing by sending multiple commands from from clients concurrently

Note: I found weird behaviour of testing code as, when I tested server using test code I could spawn less number of clients concurrently, provided server is also called from test file. But when I launched server and clients as two independent go programs, system could see increase in number of clients that can be spawned on one system.So running server and test program independently gives much better scalablity. 


## Requirements:
go 1.4.1 and higher

Features:
1.Serves more than one million requests in 15 seconds i.e it can handle more than 10000 clients at a time and each client sending 100 requests.
2.Automatic grabage collection is performed per 5 seconds and this time is tunable
3.various commands supported (mentioed in Functionalities) which gives best possible functions out of key value store.

## Limitation:
This is single server-single machine system, for critical operations and enhance scalability this system can be transformed into something like RAFT system.


## Functionalities:
(Copied from problem statement)

   1.Set: create the key-value pair, or update the value if it already exists.

    set <key> <exptime> <numbytes> [noreply]\r\n
    <value bytes>\r\n

    The server responds with:

    OK <version>\r\n  

    where version is a unique 64-bit number (in decimal format) assosciated with the key.
    Get: Given a key, retrieve the corresponding key-value pair

   2.get <key>\r\n

    The server responds with the following format (or one of the errors described later)

    VALUE <numbytes>\r\n
    <value bytes>\r\n

   3.Get Meta: Retrieve value, version number and expiry time left

     getm <key>\r\n

    The server responds with the following format (or one of the errors described below)

    VALUE <version> <exptime> <numbytes>\r\n
    <value bytes>\r\n

    4.Compare and swap. This replaces the old value (corresponding to key) with the new value only if the version is still the same.

    cas <key> <exptime> <version> <numbytes> [noreply]\r\n
    <value bytes>\r\n

    The server responds with the new version if successful (or one of the errors described late)

      OK <version>\r\n

    5.Delete key-value pair

     delete <key>\r\n

    Server response (if successful)

      DELETED\r\n

#### Options:
    1)key : an ascii text string (max 250 bytes) without spaces
    2)numbytes: size of the value block, not including the trailing \r\n. It is in an ascii text format.
    3)version: A 64-bit number generated by the server, in ascii text format.
    4)exptime: An offset in seconds after which the value may not be available. 0 indicates no expiry at all.

#### Errors that are returned.
    1) “ERR_VERSION \r\n” (the value was not changed because of a version mismatch)
    2) “ERRNOTFOUND\r\n” (the key doesn’t exist)
    3) “ERRCMDERR\r\n” (the command line is not formatted correctly)
    4) “ERR_INTERNAL\r\n
